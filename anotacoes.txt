############################################################## TRATANDO EXCEÇÕES CUSTOMIZADAS #################################################################

1 - Criar um record para retornar um Json com a exceção, sendo assim, mais amigável para o usuário. Exemplo:

    - public record ExceptionResponse(Date timestamp, String message, String details) { }

2 - Criar a exceção que será customizada, atribuindo a ela um statusCode para ser retornado com o seguinte comando:

    - @ResponseStatus(HttpStatus.BAD_REQUEST)

        * Esta anotação informa ao Spring que, sempre que essa exceção for lançada, o sistema deve retornar automaticamente o status HTTP 400
        * Também pode ser outro tipo de statusCode

3 - Criar uma classe CustomEntityResponseHandler que vai interceptar a exceção lançada e vai substituir pelo Json da record e pelo statusCode da exceção customizada
essa classe vai se anotada com as eguintes annotations:

    - @ControllerAdvice

        * indica que essa classe fornece tratamento global de exceções para todos os controladores da aplicação.
        Ela intercepta erros lançados nos @RestController automaticamente.

    - @RestController

        * Combina @Controller e @ResponseBody, o que significa que os métodos vão retornar objetos (geralmente em JSON) diretamente como resposta HTTP.
Essa classe extende a classe ResponseEntityExceptionHandler  que já tem tratamentos padrão para várias exceções do Spring
Após realizar isso, criam-se os métodos que vão realizar esse tratamento da interceptação. Exemplo:

    - @ExceptionHandler(Exception.class)
      public final ResponseEntity<ExceptionResponse> handleAllExceptions(Exception e, WebRequest request){
           ExceptionResponse response = new ExceptionResponse(new Date(), e.getMessage(), request.getDescription(false));
           return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
      }

        * Esse método realiza um tratamento mais genérico se não tiver um tratamento mais específico.
        * Esse método é acompanhado da anotation @ExceptionHandler(Exception.class) que indica que ele trata qualquer exceção
        * WebRequest request fornece o contexto da requisição (URL, headers, etc).
        * O retorno é um ResponseEntity<ExceptionResponse> — um objeto de resposta HTTP com corpo e status.
        *Cria um objeto da record ExceptionResponse com três informações:
            A data/hora atual
            A mensagem do erro
            Uma descrição da requisição, como a URL
        * Retorna o objeto response com status HTTP 500 – Internal Server Error
Esse método pode ser modificado para tratar uma exceção customizada subtituindo apenas o statusCode e o valor do @ExceptionHandler(Exception.class) pelo nome da exceção

#######################################################Icf NJEÇÃO DE DEPENDÊNCIAS#######################################################################
- @Service
- @Autowired

1 - @Service
    * A anotação `@Service` é usada para marcar uma classe de serviço no Spring. Isso basicamente diz ao SprinG
        > "Ei, essa classe aqui contém regras de negócio! Quero que você cuide dela pra mim!"
    Quando usar?
        * Quando você quer separar a lógica da aplicação em camadas
    Exemplo:
        @Service
        public class PersonServices {
            public Person findById(String id) {
                // lógica para buscar a pessoa
            }
        }
    O Spring cria automaticamente uma instância (objeto) dessa classe e a disponibiliza para ser usada em outras partes do código,
    sem que você precise fazer `new PersonServices()`.

2 - @Autowired
    * usado para injeção de dependência automática. Isso significa que o Spring vai "injetar" (ou seja, fornecer) um objeto pronto para você,
    sem você precisar criar manualmente com `new`.
    Exemplo:
        @RestController
        public class PersonController {
            @Autowired
            private PersonServices services;
        }
Isso é muito útil porque:
    - Você **não precisa se preocupar com instanciar manualmente**
    - Ajuda a manter seu código **mais limpo e organizado**

Como isso tudo funciona junto?
    1. O Spring vê a anotação `@Service` → cria um objeto da classe `PersonServices`
    2. O Spring vê `@Autowired` na `PersonController` → injeta automaticamente o objeto do passo 1
    3. Quando uma requisição chega em `/person/{id}`, o controller usa o service pra buscar a pessoa


